<?php

/**
 * @file
 * The page manager module provides a UI and API to manage pages.
 *
 * It defines pages, both for system pages, overrides of system pages, and
 * custom pages using Backdrop's normal menu system. It allows complex
 * manipulations of these pages, their content, and their hierarchy within
 * the site. These pages can be exported to code for superior revision
 * control.
 */

/**
 * Layouts constant for user-defined layouts.
 */
const LAYOUT_STORAGE_NORMAL = 1;

/**
 * Layout constant for layouts that override module-defined presets.
 */
const LAYOUT_STORAGE_OVERRIDE = 2;

/**
 * Layout constant for module-defined layouts.
 */
const LAYOUT_STORAGE_DEFAULT = 4;

/**
 * Layout constant indicating the title of the layout is the default.
 */
const LAYOUT_TITLE_DEFAULT = 'default';

/**
 * Layout constant indicating the title of the layout is not shown.
 */
const LAYOUT_TITLE_NONE = 'none';

/**
 * Layout constant indicating the title of the layout is manually specified.
 */
const LAYOUT_TITLE_CUSTOM = 'custom';

/**
 * Layout constant indicating the title of the layout comes from a block.
 */
const LAYOUT_TITLE_BLOCK = 'block';

/**
 * Implements hook_menu().
 */
function layout_menu() {
  $items = array();
  $base = array(
    'access arguments' => array('administer layouts'),
    'file' => 'includes/layout.admin.inc',
    'theme callback' => 'ajax_base_page_theme',
  );

  $items['admin/structure/layouts'] = array(
    'title' => 'Layouts',
    'description' => 'Create new landing pages or modify the layout of existing pages on your site.',
    'page callback' => 'layout_list_page',
    'type' => MENU_NORMAL_ITEM,
  ) + $base;

  $items['admin/structure/layouts/reorder'] = array(
    'title' => 'List',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('layout_reorder_form'),
    'type' => MENU_CALLBACK,
  ) + $base;

  $items['admin/structure/layouts/manage/%layout_tempstore'] = array(
    'title' => 'Edit layout settings',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('layout_content_form', 4),
    'type' => MENU_NORMAL_ITEM,
  ) + $base;

  $items['admin/structure/layouts/manage/%layout_tempstore/edit'] = array(
    'title' => 'Layout',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  ) + $base;

  $items['admin/structure/layouts/manage/%layout_tempstore/add-block/%/%'] = array(
    'title' => 'Add block',
    'page callback' => 'layout_block_add_page',
    'page arguments' => array(4, 6, 7),
  ) + $base;

  $items['admin/structure/layouts/manage/%layout_tempstore/configure-block/%/%layout_tempstore_block'] = array(
    'title' => 'Configure block',
    'load arguments' => array(4),
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('layout_block_configure_form', 4, 7, 6),
  ) + $base;

  $items['admin/structure/layouts/manage/%layout_tempstore/remove-block/%/%layout_tempstore_block'] = array(
    'title' => 'Remove block',
    'load arguments' => array(4),
    'page callback' => 'layout_block_remove_page',
    'page arguments' => array(4, 7, 6),
  ) + $base;

  $items['admin/structure/layouts/manage/%layout_tempstore/settings'] = array(
    'title' => 'Settings',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('layout_settings_form', 4),
    'type' => MENU_LOCAL_TASK,
  ) + $base;

  $items['admin/structure/layouts/manage/%layout_tempstore/clone'] = array(
    'title' => 'Clone layout',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('layout_clone_form', 4),
    'type' => MENU_CALLBACK,
  ) + $base;

  $items['admin/structure/layouts/manage/%layout_tempstore/enable'] = array(
    'page callback' => 'layout_enable_layout',
    'page arguments' => array(TRUE, 4),
    'type' => MENU_CALLBACK,
  ) + $base;

  $items['admin/structure/layouts/manage/%layout_tempstore/disable'] = array(
    'page callback' => 'layout_enable_layout',
    'page arguments' => array(FALSE, 4),
    'type' => MENU_CALLBACK,
  ) + $base;

  $items['admin/structure/layouts/manage/%layout_tempstore/delete'] = array(
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('layout_delete_form', 4),
    'type' => MENU_CALLBACK,
  ) + $base;

  $items['admin/structure/layouts/add'] = array(
    'title' => 'Add new layout',
    'page callback' => 'layout_add_page',
    'page arguments' => array(),
    'type' => MENU_LOCAL_ACTION,
  ) + $base;

  $items['admin/structure/layouts/menu/%layout_tempstore_menu_item'] = array(
    'title' => 'Menu settings',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('layout_menu_item_settings_form', 4),
    'type' => MENU_CALLBACK,
  ) + $base;

  $items['admin/structure/layouts/menu/%layout_tempstore_menu_item/arguments'] = array(
    'title' => 'Arguments',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('layout_menu_item_arguments_form', 4),
    'type' => MENU_CALLBACK,
  ) + $base;

  $items['admin/structure/layouts/menu/%layout_tempstore_menu_item/access'] = array(
    'title' => 'Access control',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('layout_menu_item_access_form', 4),
    'type' => MENU_CALLBACK,
  ) + $base;

  $items['admin/structure/layouts/manage/%layout_tempstore/condition/add'] = array(
    'title' => 'Add condition',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('layout_condition_add_form', 4),
    'type' => MENU_CALLBACK,
  ) + $base;

  $items['admin/structure/layouts/manage/%layout_tempstore/condition/edit/%'] = array(
    'title' => 'Configure condition',
    'title callback' => 'layout_condition_edit_title',
    'title arguments' => array(4, 7),
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('layout_condition_edit_form', 4, 7),
    'type' => MENU_CALLBACK,
  ) + $base;

  // Add/configure conditions for a block uses the same callback as layout.
  $items['admin/structure/layouts/manage/%layout_tempstore/condition/add/%layout_tempstore_block'] = array(
    'title' => 'Add condition',
    'load arguments' => array(4),
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('layout_condition_add_form', 4, 7),
    'type' => MENU_CALLBACK,
  ) + $base;

  $items['admin/structure/layouts/manage/%layout_tempstore/condition/edit/%/%layout_tempstore_block'] = array(
    'title' => 'Configure condition',
    'load arguments' => array(4),
    'title callback' => 'layout_condition_edit_title',
    'title arguments' => array(4, 7, 8),
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('layout_condition_edit_form', 4, 7, 8),
    'type' => MENU_CALLBACK,
  ) + $base;

  // Add menu entries for each custom layout path.
  foreach (layout_get_all_layout_menu_items() as $menu_item) {
    if (!empty($menu_item->disabled)) {
      continue;
    }

    if (!isset($menu_item->access['type'])) {
      $menu_item->access['type'] = 'none';
    }
    if (!isset($menu_item->access['settings'])) {
      $menu_item->access['settings'] = NULL;
    }

    $path             = array();
    $page_arguments   = array($menu_item->name);
    $access_arguments = array($menu_item->name);
    $load_arguments   = array($menu_item->name, '%map', '%index');

    // Replace placeholders with named placeholders for known contexts.
    foreach (explode('/', $menu_item->path) as $position => $bit) {
      $placeholder = $bit;
      if ($bit[0] === '%') {
        $placeholder = '%layout_path';
      }

      $path[]             = $placeholder;
      $page_arguments[]   = $position;
      $access_arguments[] = $position;
    }

    $menu_path = implode('/', $path);
    $items[$menu_path] = layout_page_menu_item($menu_item->menu, $access_arguments, $page_arguments, $load_arguments);

    // Add a parent menu item if one is configured.
    if (isset($menu_item->menu['type']) && $menu_item->menu['type'] == 'default tab') {
      array_pop($path);
      $parent_path = implode('/', $path);
      $items[$parent_path] = layout_page_menu_item($menu_item->menu['parent'], $access_arguments, $page_arguments, $load_arguments);
    }
  }

  return $items;
}

/**
 * Menu loader callback; Convert %layout_path placeholders to loaded objects.
 */
function layout_path_load($arg_value, $layout_name, $path_parts, $arg_position) {
  $layout = layout_load($layout_name);
  $contexts = $layout->getContexts();
  $context_info = layout_get_context_info($contexts[$arg_position]->plugin);
  if (isset($context_info['load callback']) && function_exists($context_info['load callback'])) {
    return $context_info['load callback']($arg_value);
  }

  // Pass-through the string argument if no load callback specified.
  return $arg_value;
}

/**
 * Create a menu item for page manager pages.
 *
 * @param $menu
 *   The configuration to use. It will contain a type, and depending on the
 *   type may also contain weight, title and name. These are presumed to have
 *   been configured from the UI.
 * @param $access_arguments
 *   Arguments that go with ctools_access_menu; it should be loaded with
 *   the access plugin type, settings, and positions of any arguments that
 *   may produce contexts.
 * @param $page_arguments
 *   This should be seeded with the subtask name for easy loading and like
 *   the access arguments above should contain positions of arguments so
 *   that the menu system passes contexts through.
 * @param $load_arguments
 *   Arguments to send to the arg loader; should be the subtask id and '%index'.
 */
function layout_page_menu_item($menu, $access_arguments, $page_arguments, $load_arguments) {
  $item = array(
    'access callback' => 'layout_page_access',
    'access arguments' => $access_arguments,
    'page callback' => 'layout_page_callback',
    'page arguments' => $page_arguments,
    'load arguments' => $load_arguments,
    'file' => 'includes/layout.pages.inc',
  );

  if (isset($menu['title'])) {
    $item['title'] = $menu['title'];
  }
  if (isset($menu['weight'])) {
    $item['weight'] = $menu['weight'];
  }

  if (empty($menu['type'])) {
    $menu['type'] = 'none';
  }

  switch ($menu['type']) {
    case 'normal':
      $item['type'] = MENU_NORMAL_ITEM;
      // Insert item into the proper menu
      $item['menu_name'] = $menu['name'];
      break;

    case 'tab':
      $item['type'] = MENU_LOCAL_TASK;
      break;

    case 'action':
      $item['type'] = MENU_LOCAL_ACTION;
      break;

    case 'default tab':
      $item['type'] = MENU_DEFAULT_LOCAL_TASK;
      break;
    case 'none':
    default:
      $item['type'] = MENU_CALLBACK;
      break;
  }

  return $item;
}

/**
 * Menu access callback; Check access for any Layout-provided page.
 */
function layout_page_access() {
  module_load_include('inc', 'layout', 'includes/layout.pages');
  $args = func_get_args();
  return call_user_func_array('_layout_page_access', $args);
}

/**
 * Check to see if the incoming menu item is js capable or not.
 *
 * This can be used as %layout_js as part of a path in hook menu. CTools
 * ajax functions will automatically change the phrase 'nojs' to 'ajax'
 * when it attaches ajax to a link. This can be used to autodetect if
 * that happened.
 */
function layout_js_load($js) {
  if ($js == 'ajax') {
    return TRUE;
  }
  return 0;
}

/**
 * Route handler callback; Execute the current route item or wrap in a layout.
 *
 * @param $router_item
 *   The menu router item for the page currently being loaded.
 * @return
 *   The fully built HTML content for this page, which will be wrapped in
 *   page.tpl.php.
 *
 * @ingroup callbacks
 */
function layout_route_handler($router_item) {
  // If not returning HTML (e.g. AJAX or something else), use the default route
  // handler instead of layouts.
  if (!backdrop_is_html() || $router_item['page_callback'] === 'layout_page_callback') {
    return menu_default_route_handler($router_item);
  }

  $layouts = layout_get_path_layout_names($router_item['path']);
  $selected_layout = NULL;
  foreach ($layouts as $layout_name) {
    $layout = layout_load($layout_name);
    if ($layout->checkAccess()) {
      $selected_layout = $layout;
    }
  }

  if (!$selected_layout) {
    if (path_is_admin($_GET['q'])) {
      $selected_layout = layout_load('layout_admin_default');
    }
    else {
      $selected_layout = layout_load('layout_default');
    }
  }

  if ($selected_layout) {
    // Set the data in each context based on the provided menu handler.
    $contexts = $selected_layout->getContexts();
    foreach ($contexts as $position => $context) {
      if (is_numeric($position)) {
        $context->setData($router_item['map'][$position]);
      }
    }

    // Render the layout.
    $renderer = layout_create_renderer('standard', $selected_layout);
    if ($selected_layout->isDefault()) {
      $renderer->ensurePageContentBlock();
    }
    return $renderer->render();
  }

  // Fallback code if even the expected default layout cannot be found.
  return menu_default_route_handler($router_item);
}

/**
 * Implements hook_theme()
 */
function layout_theme() {
  // Include the theme file so that the base process/preprocess functions are
  // in the global namespace.
  module_load_include('inc', 'layout', 'includes/layout.theme');

  $base = array(
    'file' => 'includes/layout.theme.inc',
  );

  $items = array(
    'layout' => array(
      'variables' => array('content' => NULL, 'settings' => NULL, 'layout' => NULL, 'layout_info' => NULL, 'renderer' => NULL, 'attributes_array' => array(), 'admin' => FALSE),
      'template' => 'layouts/onecol/layout',
    ) + $base,
    'layout_reorder_layouts' => array(
      'render element' => 'element',
    ) + $base,
    'layout_content_form' => array(
      'template' => 'templates/layout-content-form',
      'render element' => 'form',
    ) + $base,
    'layout_info' => array(
      'variables' => array('layout' => NULL),
    ) + $base,
    'layout_option' => array(
      'variables' => array('layout_info' => NULL),
    ) + $base,
    'layout_menu_item_arguments_table' => array(
      'render element' => 'element',
    ) + $base,
    'layout_settings_context_table' => array(
      'render element' => 'element',
    ) + $base,
    'layout_block__system__main' => array(
      'template' => 'templates/layout-block--system--main',
      'variables' => array('layout' => NULL, 'content' => NULL, 'block' => NULL, 'style' => NULL, 'settings' => array(), 'attributes_array' => array()),
      'preprocess functions' => array('template_preprocess', 'template_preprocess_layout_block'),
    ) + $base,
  );

  // Register all layouts.
  $layouts = _layout_get_all_info('layout');
  foreach ($layouts as $layout) {
    foreach (array('theme', 'admin theme') as $callback) {
      if (!empty($layout[$callback])) {
        $items[$layout[$callback]] = array(
          'variables' => array('content' => NULL, 'settings' => NULL, 'layout' => NULL, 'layout_info' => NULL, 'renderer' => NULL, 'attributes_array' => array(), 'admin' => FALSE),
          'path' => $layout['path'],
          'base hook' => 'layout',
        );
        if (isset($layout['file'])) {
          $items[$layout[$callback]]['file'] = $layout['file'];
        }
        // If no theme function exists, assume template.
        if (!function_exists('theme_' . $layout['theme'])) {
          $items[$layout[$callback]]['template'] = str_replace('_', '-', $layout[$callback]);
        }
      }
    }
  }

  // Register all styles.
  $styles = _layout_get_all_info('layout_style');
  foreach ($styles as $style) {
    if (!empty($style['block theme'])) {
      $items[$style['block theme']] = array(
        'variables' => array('layout' => NULL, 'content' => NULL, 'block' => NULL, 'style' => NULL, 'settings' => array(), 'attributes_array' => array()),
        'base hook' => 'layout_style',
      );
      if (isset($style['file'])) {
        $items[$style['block theme']]['file'] = $style['file'];
      }
      if (isset($style['path'])) {
        $items[$style['block theme']]['path'] = $style['path'];
      }
      if (isset($style['template'])) {
        $items[$style['block theme']]['template'] = $style['template'];
      }
    }
    if (!empty($style['region theme'])) {
      $items[$style['region theme']] = array(
        'variables' => array('layout' => NULL, 'blocks' => NULL, 'style' => NULL, 'settings' => array(), 'attributes_array' => array()),
        'base hook' => 'layout_region',
      );
      if (isset($style['file'])) {
        $items[$style['region theme']]['file'] = $style['file'];
      }
      if (isset($style['path'])) {
        $items[$style['region theme']]['path'] = $style['path'];
      }
      if (isset($style['template'])) {
        $items[$style['region theme']]['path'] = $style['path'];
      }
    }

    if (!empty($style['hook theme'])) {
      if (is_array($style['hook theme'])) {
        $items += $style['hook theme'];
      }
      else if (function_exists($style['hook theme'])) {
        $style['hook theme']($items, $style);
      }
    }
  }

  return $items;
}

/**
 * Implements hook_permission().
 */
function layout_permission() {
  return array(
    'administer layouts' => array(
      'title' => t('Administer Layouts'),
      'description' => t('Add and modify layouts on pages.'),
      'restrict access' => TRUE,
    ),
  );
}

/**
 * Implements hook_layout_api().
 */
function layout_layout_api() {
  return array(
    'file' => 'includes/layout.layout.inc',
  );
}

/**
 * Implements hook_autoload_info().
 */
function layout_autoload_info() {
  return array(
    'LayoutHandler' => 'includes/layout_handler.class.inc',
    'LayoutHandlerBroken' => 'includes/layout_handler.class.inc',
    'Layout' => 'includes/layout.class.inc',
    'LayoutBlock' => 'includes/layout_block.class.inc',
    'LayoutBlockLegacy' => 'includes/layout_block_legacy.class.inc',
    'LayoutMenuItem' => 'includes/layout_menu_item.class.inc',

    // Exceptions.
    'LayoutMissingException' => 'includes/layout.exceptions.inc',

    // Context handlers.
    'LayoutContext' => 'plugins/context/layout_context.inc',
    'LayoutContextBroken' => 'plugins/context/layout_context.inc',
    'LayoutStringContext' => 'plugins/context/layout_context.inc',
    'NodeLayoutContext' => 'plugins/context/node_layout_context_handler.inc',
    'UserLayoutContext' => 'plugins/context/user_layout_context_handler.inc',

    // Access handlers.
    'EntityBundleLayoutAccess' => 'plugins/access/entity_bundle_layout_access.inc',
    'LayoutAccess' => 'plugins/access/layout_access.inc',
    'LayoutAccessBroken' => 'plugins/access/layout_access.inc',
    'LayoutAccessNegatable' => 'plugins/access/layout_access.inc',
    'LanguageLayoutAccess' => 'plugins/access/language_layout_access.inc',
    'FrontLayoutAccess' => 'plugins/access/front_layout_access.inc',
    'PathLayoutAccess' => 'plugins/access/path_layout_access.inc',
    'UserRoleLayoutAccess' => 'plugins/access/user_role_layout_access.inc',
    'UserPermissionLayoutAccess' => 'plugins/access/user_permission_layout_access.inc',

    // Renderer handlers.
    'LayoutRendererEditor' => 'plugins/renderers/layout_renderer_editor.inc',
    'LayoutRendererSimple' => 'plugins/renderers/layout_renderer_simple.inc',
    'LayoutRendererStandard' => 'plugins/renderers/layout_renderer_standard.inc',

    // Styles.
    'LayoutStyle' => 'plugins/styles/layout_style_default.inc',
    'LayoutStyleDynamic' => 'plugins/styles/layout_style_dynamic.inc',
  );
}

/**
 * Return an array of all layouts as fully loaded Layout objects.
 */
function layout_get_all_layouts() {
  $layouts = &backdrop_static(__FUNCTION__);
  if (!isset($layouts)) {
    $layouts = array();
    $menu_items = layout_get_all_layout_menu_items();

    // Cache the raw config files once read.
    if ($cache = cache()->get('layout:layouts:config')) {
      $configs = $cache->data;
    }
    else {
      $configs = array();
      $config_names = config_get_names_with_prefix('layout.layout.');
      foreach ($config_names as $config_file) {
        $config = config($config_file);
        $data = $config->get();
        $data += array(
          'weight' => 0,
        );
        $configs[$data['name']] = $data;
      }
      // Sort the configs by path and weight.
      uasort($configs, function($a, $b) {
        if ($a['path'] == $b['path']) {
          if ($a['weight'] == $b['weight']) {
            return 0;
          }
          return ($a['weight'] < $b['weight']) ? -1 : 1;
        }
        else {
          // NULL paths mean default layouts, put them last.
          if ($b['path'] === NULL) {
            return -1;
          }
          elseif ($a['path'] === NULL) {
            return 1;
          }
          return strcmp($a['path'], $b['path']);
        }
      });
      cache()->set('layout:layouts:config', $configs);
    }

    foreach ($configs as $layout_name => $layout_data) {
      // Create the layout from the configuration.
      $layouts[$layout_name] = new Layout($layout_data);

      // Associate the applicable menu item.
      if (isset($menu_items[$layout_data['path']])) {
        $layouts[$layout_name]->menu_item = $menu_items[$layout_data['path']];
      }
      else {
        $layouts[$layout_name]->menu_item = NULL;
      }
    }
  }

  return $layouts;
}

/**
 * Return an array of all menu items as fully loaded LayoutMenuItem objects.
 */
function layout_get_all_layout_menu_items() {
  $menu_items = &backdrop_static(__FUNCTION__);
  if (!isset($menu_items)) {

    // Cache the raw config files once read.
    if ($cache = cache()->get('layout:menu_items:config')) {
      $configs = $cache->data;
    }
    else {
      $configs = array();
      $config_names = config_get_names_with_prefix('layout.menu_item.');
      foreach ($config_names as $config_file) {
        $config = config($config_file);
        $data = $config->get();
        $configs[$data['name']] = $data;
      }
      cache()->set('layout:menu_items:config', $configs);
    }

    $menu_items = array();
    foreach ($configs as $data) {
      $menu_items[$data['path']] = new LayoutMenuItem($data);
    }
  }
  return $menu_items;
}

/**
 * Get a list of layouts that share a particular path.
 */
function layout_get_path_layout_names($path) {
  $path_map = array();
  // @todo: This desperately needs optimization or at least its own cache.
  $layouts = layout_get_all_layouts();
  foreach ($layouts as $name => $layout) {
    $path_map[$layout->getPath()][] = $name;
  }

  return isset($path_map[$path]) ? $path_map[$path] : array();
}

/**
 * Load an individual layout.
 */
function layout_load($layout_name) {
  $layouts = layout_get_all_layouts();
  return isset($layouts[$layout_name]) ? $layouts[$layout_name] : FALSE;
}

/**
 * Load an individual Layout menu item.
 */
function layout_menu_item_load($menu_item_name) {
  $menu_items = layout_get_all_layout_menu_items();
  $path = config_get('layout.menu_item.' . $menu_item_name, 'path');
  return ($path && isset($menu_items[$path])) ? $menu_items[$path] : FALSE;
}

/**
 * Load an individual Layout menu item based on its path.
 */
function layout_menu_item_load_by_path($path) {
  $menu_items = layout_get_all_layout_menu_items($path);
  return isset($menu_items[$path]) ? $menu_items[$path] : FALSE;
}

/**
 * Check if a path is provided by Layout module, as in a custom layout path.
 *
 * @return
 *   Boolean TRUE if Layout module provides a path, FALSE if another module
 *   specified the path, or NULL if a path does not exist in the system.
 */
function layout_provides_path($path) {
  $result = db_query('SELECT * FROM {menu_router} WHERE path = :path', array(':path' => $path));
  $return = NULL;

  // If any page callback exists at this path, allow it to trump custom layouts.
  foreach ($result as $router) {
    if ($router->page_callback == 'layout_page_callback') {
      $return = TRUE;
    }
    else {
      $return = FALSE;
      break;
    }
  }
  return $return;
}

/**
 * Reset all caches provided by Layout module.
 */
function layout_reset_caches() {
  cache()->delete('layout:layouts:config');
  cache()->delete('layout:menu_items:config');

  backdrop_static_reset('layout_get_all_layouts');
  backdrop_static_reset('layout_get_all_layout_menu_items');
}

/**
 * Load all include files for modules that implement hook_layout_api().
 */
function _layout_include_files() {
  $included = &backdrop_static(__FUNCTION__, FALSE);
  if (!$included) {
    foreach (module_implements('layout_api') as $module) {
      $function = $module . '_layout_api';
      $api_info = $function();
      if (isset($api_info['file'])) {
        include_once(BACKDROP_ROOT . '/' . backdrop_get_path('module', $module) . '/' . $api_info['file']);
      }
    }
    $included = TRUE;
  }
}

/**
 * Load a layout-related information from modules.
 */
function _layout_get_all_info($data_type) {
  $all_info = &backdrop_static(__FUNCTION__);
  if (!isset($all_info[$data_type])) {
    _layout_include_files();
    if ($cached_info = cache()->get($data_type . '_info')) {
      $all_info[$data_type] = $cached_info->data;
    }
    else {
      $all_info[$data_type] = array();
      foreach (module_implements($data_type . '_info') as $module) {
        $function = $module . '_' . $data_type . '_info';
        $data = $function();
        $module_path = backdrop_get_path('module', $module);
        foreach ($data as $key => $info) {
          $info['module'] = $module;
          $info['name'] = $key;
          if (isset($info['path'])) {
            $info['path'] = $module_path . '/' . $info['path'];
          }
          $all_info[$data_type][$key] = $info;
        }
      }
      cache()->set($data_type . '_info', $all_info[$data_type]);
    }
  }
  return $all_info[$data_type];
}

/**
 * Load all layout information from modules.
 */
function layout_get_layout_info($plugin_name) {
  $info = _layout_get_all_info('layout');
  return isset($info[$plugin_name]) ? $info[$plugin_name] : FALSE;
}

/**
 * Load all layout context information from modules.
 */
function layout_get_context_info($plugin_name) {
  $info = _layout_get_all_info('layout_context');
  return isset($info[$plugin_name]) ? $info[$plugin_name] : FALSE;
}

/**
 * Load all layout access information from modules.
 */
function layout_get_access_info($plugin_name) {
  $info = _layout_get_all_info('layout_access');
  return isset($info[$plugin_name]) ? $info[$plugin_name] : FALSE;
}

/**
 * Load all layout renderer information from modules.
 */
function layout_get_renderer_info($plugin_name) {
  $info = _layout_get_all_info('layout_renderer');
  return isset($info[$plugin_name]) ? $info[$plugin_name] : FALSE;
}

/**
 * Load all layout style information from modules.
 */
function layout_get_style_info($plugin_name) {
  $info = _layout_get_all_info('layout_style');
  return isset($info[$plugin_name]) ? $info[$plugin_name] : FALSE;
}

/**
 * Get information about all blocks or just a single one.
 *
 * @param $block_module
 *   The name of a module providing the desired block.
 * @param $block_delta
 *   The key of the block within that module.
 */
function layout_get_block_info($block_module = NULL, $block_delta = NULL) {
  $block_info = &backdrop_static(__FUNCTION__, array());

  // @todo: Add caching here.
  if (empty($block_info)) {
    foreach (module_implements('block_info') as $module) {
      $module_blocks = module_invoke($module, 'block_info');
      foreach ($module_blocks as $delta => $block) {
        $block_info[$module . ':' . $delta] = $block;
      }
    }
  }

  if (isset($block_module) && isset($block_delta)) {
    $block_key = $block_module . ':' . $block_delta;
    return isset($block_info[$block_key]) ? $block_info[$block_key] : FALSE;
  }

  return $block_info;
}

/**
 * Helper function to get a handler class name based on the plugin name.
 */
function layout_get_handler_name($plugin_type, $plugin_name) {
  // Block "plugins" for Layouts are wrappers around the generic block system.
  if ($plugin_type === 'block') {
    $info = layout_get_block_info();
    if ($info[$plugin_name]) {
      if (isset($info[$plugin_name]['class'])) {
        $class_name = 'LayoutBlockStandard';
      }
      else {
        $class_name = 'LayoutBlockLegacy';
      }
    }
    else {
      $class_name = 'LayoutBlockBroken';
    }
  }
  else {
    $info = _layout_get_all_info($plugin_type);
    switch ($plugin_type) {
      case 'layout_access':
        $broken_class = 'LayoutAccessBroken';
        break;
      case 'layout_context':
        $broken_class = 'LayoutContextBroken';
        break;
      case 'layout_style':
        $broken_class = 'LayoutStyle';
        break;
    }

    if (isset($info[$plugin_name]['class']) && class_exists($info[$plugin_name]['class'])) {
      $class_name = $info[$plugin_name]['class'];
    }
    else {
      $class_name = $broken_class;
    }
  }
  return $class_name;
}

/**
 * Helper function to instantiate handlers when loading from config.
 *
 * @param string $plugin_type
 *   The type of plugin being loaded, i.e. 'context', 'access', etc.
 * @param string $plugin_name
 *   The name of the plugin, as keyed by that plugin type's info hooks.
 * @param array $config
 *   The configuration options for the handler being created.
 * @return
 *   A handler object instance of the specified plugin type.
 */
function layout_create_handler($plugin_type, $plugin_name, array $config = array()) {
  $handler_name = layout_get_handler_name($plugin_type, $plugin_name);
  return new $handler_name($plugin_name, $config);
}

/**
 * Helper function to create a Layout Context.
 *
 * @return LayoutContext
 */
function layout_create_context($context_plugin_name, $config = array()) {
  return layout_create_handler('layout_context', $context_plugin_name, $config);
}

/**
 * Helper function to create a Layout Access.
 *
 * @return LayoutAccess
 */
function layout_create_access($access_plugin_name, $config = array()) {
  return layout_create_handler('layout_access', $access_plugin_name, $config);
}

/**
 * Helper function to create a Layout Renderer.
 *
 * @return LayoutRenderer
 */
function layout_create_renderer($renderer_plugin_name, Layout $layout) {
  // Renderers do not have "broken" classes if they do not exist. As renderers
  // are not part of configuration, they should never go missing.
  $renderer_info = layout_get_renderer_info($renderer_plugin_name);
  return new $renderer_info['class']($layout, $renderer_info);
}

/**
 * Get the cached changes to a given task handler.
 *
 * The page cache is used to store a page temporarily, using the ctools object
 * cache. When loading from the page cache, it will either load the cached
 * version, or if there is not one, load the real thing and create a cache
 * object which can then be easily stored.
 *
 * @param string $name
 *   The machine name of the Layout item to load.
 * @param string $type
 *   The type of item to load. Must be either "layout" or "menu_item".
 */
function layout_get_layout_tempstore($name, $type = 'layout') {
  $caches = &backdrop_static(__FUNCTION__, array());
  if (!isset($caches[$type][$name])) {
    // Try loading from tempstore first to get in-progress changes.
    $item = tempstore_get('layout.' . $type, $name);
    if (!$item) {
      if ($type == 'layout') {
        $item = layout_load($name);
      }
      elseif ($type == 'menu_item') {
        $item = layout_menu_item_load($name);
      }
    }
    $caches[$type][$name] = $item;
  }

  return $caches[$type][$name];
}

/**
 * Store changes to a task handler in the object cache.
 */
function layout_set_layout_tempstore($item, $type = 'layout') {
  if (!empty($item->locked)) {
    return;
  }
  if (empty($item->name)) {
    return;
  }
  $item->changed = TRUE;
  tempstore_set('layout.' . $type, $item->name, $item, 604800);
}

/**
 * Remove an item from the object cache.
 */
function layout_clear_layout_tempstore($name, $type = 'layout') {
  tempstore_clear('layout.' . $type, $name);
}

/**
 * Menu loader callback to load a Layout cache object.
 */
function layout_tempstore_load($layout_name) {
  return layout_get_layout_tempstore($layout_name, 'layout');
}


/**
 * Menu loader callback to load a Layout cache object.
 */
function layout_tempstore_menu_item_load($layout_name) {
  return layout_get_layout_tempstore($layout_name, 'menu_item');
}

/**
 * Menu loader to load an individual block from a layout.
 */
function layout_tempstore_block_load($layout_block_uuid, $layout_name) {
  $layout = layout_tempstore_load($layout_name);
  $block = FALSE;
  if (isset($layout->in_progress['block']) && $layout->in_progress['block']->uuid === $layout_block_uuid) {
    $block = $layout->in_progress['block'];
  }
  elseif (isset($layout->content[$layout_block_uuid])) {
    $block = $layout->content[$layout_block_uuid];
  }
  return $block;
}

/**
 * Given a path with wildcard placeholders (%), determine the required contexts.
 *
 * @param string $path
 *   The path for which required contexts should be retrieved.
 * @return array
 *   An array of required contexts that match the given path.
 */
function layout_context_required_by_path($path) {
  $required_context_info = array();

  // Populate each required context on the available known handlers.
  $all_info = _layout_get_all_info('layout_context');
  foreach ($all_info as $context_info) {
    foreach ($context_info['menu paths'] as $context_path) {
      // Remove named placeholders to just match on % symbols.
      $cleaned_path = preg_replace('/%[a-z0-9_]+/', '%', $context_path);
      // If the path matches based on % wildcards, add this context as a
      // required context info in the correct order.
      if (strpos($path, $cleaned_path) === 0) {
        // Get the first named argument.
        $loader_part = key($context_info['menu loaders']);
        // Determine the argument placement within the path
        $parts = explode('/', $context_path);
        foreach ($parts as $part_index => $part) {
          if ($part === $loader_part) {
            $required_context_info[$part_index] = array(
              'plugin' => $context_info['name'],
              'position' => $part_index,
            );
          }
        }
      }
    }
  }

  // If any wildcards are not filled, populate with a placeholder context
  // that can be modified.
  $parts = explode('/', $path);
  foreach ($parts as $part_index => $part) {
    if ($part === '%' && !isset($required_context_info[$part_index])) {
      $required_context_info[$part_index] = array(
        'plugin' => 'string',
        'position' => $part_index,
      );
    }
  }

  // Put the required contexts in order based on the path.
  ksort($required_context_info);

  // Convert required context info into objects.
  $required_contexts[$path] = array();
  foreach ($required_context_info as $context_position => $context_info) {
    $context = layout_create_handler('layout_context', $context_info['plugin']);
    $context->required = TRUE;
    // String placeholders are not locked, allowing a new value to be set.
    $context->locked = $context_info['plugin'] !== 'string';
    $context->position = $context_position;
    $context->plugin = $context_info['plugin'];
    $required_contexts[$path][$context_position] = $context;
  }

  return $required_contexts[$path];
}

/**
 * Helper function for setting contexts on a layout handler.
 *
 * @param array $contexts
 *   An array of contexts that will be set by reference if all required contexts
 *   are found.
 * @param array $all_contexts
 *   The full array of contexts on an entire layout, from which the required
 *   contexts will be selected.
 * @param array $required_contexts
 *   The array of context keys and types that need to be selected from
 *   the $all_contexts array and populated into the $contexts array.
 * @param array $context_settings
 *   If a plugin has multiple contexts, a user may select which context should
 *   be used. This array will be keyed by the plugin's required context keys,
 *   with the values being the overall layout's context keys.
 */
function layout_set_handler_contexts(array &$contexts, array $all_contexts, array $required_contexts, array $context_settings) {
  foreach ($required_contexts as $required_context_key => $context_type) {
    // Use the configured context if available.
    if (isset($context_settings[$required_context_key])) {
      $layout_context_key = $context_settings[$required_context_key];
      if (isset($all_contexts[$layout_context_key]) && $all_contexts[$layout_context_key]->plugin === $context_type) {
        $contexts[$required_context_key] = $all_contexts[$layout_context_key];
        break;
      }
    }
    // Otherwise use the first context that matches the right type.
    foreach ($all_contexts as $layout_context) {
      if ($context_type == $layout_context->plugin) {
        $contexts[$required_context_key] = $layout_context;
        break 2;
      }
    }
    // If we reach here, no matching required context was found, empty all
    // contexts to prevent partial functionality and return FALSE.
    $contexts = array();
    return FALSE;
  }

  // All required contexts populated successfully.
  return TRUE;
}
